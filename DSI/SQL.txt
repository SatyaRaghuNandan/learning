Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2017-01-12T12:54:52+00:00

====== SQL ======
Created Thursday 12 January 2017

PostgreSQL performance:
	http://okigiveup.net/what-postgresql-tells-you-about-its-performance/
	
High-Performance Blog:
	https://www.periscopedata.com/blog/interactive-analytics-redshift-bigquery-snowflake.html
	
Example of Clean Code:
	http://jonathansacramento.com/posts/20161119_clean_sql.html#
	
AWS Redshift:
	performance deep dive: https://www.youtube.com/watch?v=fmy3jCxUliM
	2016 what's new: https://www.youtube.com/watch?v=OyHhYIUEPQ4
	
To Learn:
	MySQL, PostgreSQL
	Cloud Analytics solution: AWS RedShift
	
Topics:
	materialized views
	partition key
	indexing
	why use a view vs. a table?
	why use a CTE?
		CTEs (common table expressions), temp tables by WITH clauses, it allows you to create something somewhat equivilant to a view that only exists during that transaction.
		Readability is huge when it comes to SQL to ensure its doing the right thing. SQL will almost always tell you an answer, it just may not be to the question you think you’re asking. Ensuring your queries can be reasoned about is critical to ensuring accuracy and CTEs are one great way of accomplishing that.

**Transactional Integrity**
	every part of the transaction must be completed before the whole process is done
	
**Guaranteeing Transaction Reliability** (often asked during interview)
	There is a set of properties known by the acronym ACID that guarantee that database transactions are processed reliably and
	concurrently:
	1. Atomicity: all or nothing
	2. Consistency: The consistency property ensures that any transaction will bring the database from one valid state to another. All related tables must be updated at the same time you make an update in one table (one reason that NoSQL was invented)
	3. Isolation:  This property ensures that the concurrent execution of transactions results in a system state that would be obtained if transactions were executed sequentially(databases use date-time, timestamp) Imagine you make 8 updates and then a selection right after, you expect to see the updated data!
	4. Durability: It ensures that once a transaction has been committed, it will remain so, even in the event of power loss, crashes, or errors (once a change has been committed, it will be saved somewhere all the time).
		https://en.wikipedia.org/wiki/ACID

**BASE ( NoSQL version of ACID)**
	1. Basically available indicates that the system does guarantee availability. (multiple threads can write at the same time for NoSQL; but for SQL, all threads has to merge before they can write in the destination 
	2. Soft state indicates that the state of the system may change over time, even without input.???
	3. Eventual consistency indicates that the system will become consistent over time, given that the system doesn't receive input during that time. (Don't care when a transaction will happen, given knowing it will be there eventually)	

	Main concept: get rid of locks, allow everyone to write, worry about consistency later; writes faster

**Misc:**
1. Whenever possible, don’t use a nested queries
2. **Distinct** is same as **Group By**. 
3. Monotone query: Whenever we add tuples to one or more input tables, the answer to the query will not lose any of the tuples
	a. Theorem: If Q is a SELECT-FROM-WHERE query that does not have subqueries, and no aggregates, then it is monotone.
4. Relation, Tuple, Attribute == Table, Row, Column
5. file types: Heap (unsorted), Sequential (sorted in someway)
************************************************************************************************************************************************
**Data Management Concepts**
	* Data models: how to describe real-world data
		–  Relational, XML(eXtensible Markup Language), graph data (RDF: Resource Description Framework)
	* Schema v.s. Data
	* Declarative query language
		–  Say what you want, not how to get it
	* Data independence
		–  Physical independence: Can change how data is stored on disk without maintenance to applications
		–  Logical independence: can change schema w/o affecting apps
	* Query optimizer and compiler
	* Transactions: isolation and atomicity

**Where vs. Having**
	* WHERE condition is applied to individual rows
		–  The rows may or may not contribute to the aggregate
		–  No aggregates allowed here
	* HAVING condition is applied to the entire group
		–  Entire group is returned, or not at all
		–  May use aggregate functions in the group

**Queries that must be nested**
	* Queries with //universal quantifiers// (ALL) or with //negation (Not In, Not Exist ...)//
	* Queries that use aggregates in certain ways
		–  Note: sum(..) and count(*) are NOT monotone, because they do not satisfy set containment
		–  select count(*) from R is not monotone!

**Relational Algebra (How to get the data we want)**
	Relational algebra expression is also called the **“logical query plan"**
	A **Physical Query Plan**: a logical query plan annotated with physical implementation details
	
	For each SQL query... many logical plans
	For each logical plan... many physical plans
		e.g. For an inner join: Nest Loop Join, Merge Join, Hash Join

**Query Execution**
	Pipelined Execution (use whenever possible)
	Intermediate Tuple Materialization (for certain operator implementations, not enough memory)
	
**Index**
	Index Organization: B+ trees, Hash Table, Bit Maps, R-trees, Inverted Index
	Clustered (only one) vs. Unclustered (possibly many)
	Primary (over attributes that include the Primary Key) vs. Secondary 
	
	Random reading 1-2% of the file ≈ sequential scanning the entire file;
	
	Each new index slows down updates to table
	
	**Index Selection Problem** is HARD, done by DBA
		Make some attribute K a search key if the WHERE clause contains:
			–  An exact match on K
			–  A range predicate on K
			–  A join on K
		Consider queries in workload in order of importance
		Consider relations accessed by query
			–  No point indexing other relations
		Look at WHERE clause for possible search key
		Try to choose indexes that speed-up multiple queries

**Database Design**
	Starting from scratch, design the database schema: relation, attributes, keys, foreign keys, constraints etc
	

